import pandas as pd
from rapidfuzz import fuzz
import numpy as np
import multiprocessing
from functools import partial

def fuzzy_match(domain_email, website):
    if pd.isna(domain_email) or pd.isna(website):
        return np.nan
    similarity = fuzz.ratio(str(domain_email).lower(), str(website).lower())
    if similarity >= 90:
        return website
    return np.nan

def parallel_fuzzy_match(df1, df2, column1, column2):
    """
    Parallelized fuzzy matching function.
    """
    # Create a list to store results
    results = []
    
    # Iterate over each row in df1
    for _, row1 in df1.iterrows():
        match = None
        # Iterate over each row in df2
        for _, row2 in df2.iterrows():
            # Calculate fuzzy match score
            score = fuzz.ratio(str(row1[column1]).lower(), str(row2[column2]).lower())
            # Check if score is above threshold
            if score >= 90:
                match = row2[column2]
                break  # Break if match is found
        results.append(match)
    return results

def optimized_match_sheets_separate(file_path_sheet1, file_path_sheet2):
    """
    Match data between Sheet 1 and Sheet 2 when they are in separate Excel files, using optimized methods and parallel processing.
    """
    # Read Sheet 1
    df_sheet1 = pd.read_excel(file_path_sheet1)

    # Read Sheet 2
    df_sheet2 = pd.read_excel(file_path_sheet2)

    # Create a copy of Sheet 1 for output
    output_df = df_sheet1.copy()
    output_df['Match'] = np.nan
    output_df['Match'] = output_df['Match'].astype(object)

    # Convert columns to appropriate types and lowercase for matching
    for col in ['Account_Hosp_Id_r', 'Account_Mco__Id_r']:
        if col in df_sheet1.columns:
            df_sheet1[col] = df_sheet1[col].astype(str).str.lower()
    for col in ['Account_Hosp_Id', 'Account_Mco__Id']:
        if col in df_sheet2.columns:
            df_sheet2[col] = df_sheet2[col].astype(str).str.lower()
    # Helper function to apply fuzzy matching
    def apply_fuzzy_matching(unmatched_idx, col1, col2):
        if unmatched_idx.any():
            # Parallelize the fuzzy matching
            num_processes = multiprocessing.cpu_count()  # Use all available CPUs
            pool = multiprocessing.Pool(processes=num_processes)
            
            # Prepare arguments for parallel processing
            df1_split = np.array_split(df_sheet1.loc[unmatched_idx], num_processes)
            
            # Use partial to pass additional arguments to the function
            partial_parallel_fuzzy_match = partial(parallel_fuzzy_match, df2=df_sheet2, column1=col1, column2=col2)
            
            # Apply fuzzy matching in parallel
            results = pool.map(partial_parallel_fuzzy_match, df1_split)
            
            # Close the pool and wait for the work to finish
            pool.close()
            pool.join()
            
            # Flatten the results list
            results = [item for sublist in results for item in sublist]
            
            # Assign the results to the output DataFrame
            output_df.loc[unmatched_idx, 'Match'] = results
        return output_df

    # 1. Check Account_Hosp_Id_r vs Account_Hosp_Id
    merged_hosp = pd.merge(df_sheet1, df_sheet2, left_on='Account_Hosp_Id_r', right_on='Account_Hosp_Id', how='left')
    output_df.loc[merged_hosp['Account_Hosp_Id'].notna(), 'Match'] = merged_hosp.loc[merged_hosp['Account_Hosp_Id'].notna(), 'Id_y'].values

    # 2. Check Account_Mco__Id_r vs Account_Mco__Id for unmatched rows
    unmatched_idx = output_df['Match'].isna()
    merged_mco = pd.merge(df_sheet1[unmatched_idx], df_sheet2, left_on='Account_Mco__Id_r', right_on='Account_Mco__Id', how='left')
    output_df.loc[merged_mco['Account_Mco__Id'].notna(), 'Match'] = merged_mco.loc[merged_mco['Account_Mco__Id'].notna(), 'Id_y'].values

    # 3. Check DomainEmail vs Website for unmatched rows with fuzzy matching
    unmatched_idx = output_df['Match'].isna()
    output_df = apply_fuzzy_matching(unmatched_idx, 'DomainEmail', 'Website')

    # 4. Check Account_Name vs Name for unmatched rows with fuzzy matching
    unmatched_idx = output_df['Match'].isna()
    output_df = apply_fuzzy_matching(unmatched_idx, 'Account_Name', 'Name')

    # 5. Check Company vs Name for unmatched rows with fuzzy matching
    unmatched_idx = output_df['Match'].isna()
    output_df = apply_fuzzy_matching(unmatched_idx, 'Company', 'Name')

    return output_df

def main():
    # File paths for Sheet 1 and Sheet 2
    file_path_sheet1 = r'C:\sheet1_data.xlsx'
    file_path_sheet2 = r'C:\sheet2_data.xlsx'

    # Match the sheets
    result_df = optimized_match_sheets_separate(file_path_sheet1, file_path_sheet2)

    # Write the output to a new Excel file
    output_file = 'matching_output.xlsx'
    result_df.to_excel(output_file, index=False)
    print(f"Matching complete. Output written to {output_file}")

if __name__ == "__main__":
    main()
