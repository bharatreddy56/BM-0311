import pandas as pd
import numpy as np
from rapidfuzz import process, fuzz
from concurrent.futures import ProcessPoolExecutor
import os

# ========== FILE PATHS CONFIGURATION ========== #
INPUT_DIR = r'C:\your\input\directory'  # Update this path
OUTPUT_DIR = r'C:\your\output\directory'  # Update this path

sheet1_path = os.path.join(INPUT_DIR, 'sheet1.xlsx')
sheet2_path = os.path.join(INPUT_DIR, 'sheet2.xlsx')
output_path = os.path.join(OUTPUT_DIR, 'matched_output.xlsx')
# ============================================== #

def fuzzy_match_wrapper(args):
    return process.extractOne(args[0], args[1], scorer=fuzz.WRatio, score_cutoff=90)

def optimize_matching(sheet1, sheet2):
    # Convert to categorical for memory optimization
    sheet1 = sheet1.astype({col: 'category' for col in sheet1.select_dtypes('object').columns})
    sheet2 = sheet2.astype({col: 'category' for col in sheet2.select_dtypes('object').columns})

    # Create lookup dictionaries for exact matches
    hosp_lookup = sheet2.set_index('Account_Hosp_Id')['Account_Hosp_Id'].to_dict()
    mco_lookup = sheet2.set_index('Account_Mco__Id')['Account_Mco__Id'].to_dict()
    website_lookup = sheet2.set_index('Website')['Website'].to_dict()
    
    # Precompute fuzzy match candidates
    sheet2_names = sheet2['Name'].unique().tolist()
    
    # Vectorized exact matching
    sheet1['Match'] = np.nan
    mask = sheet1['Account_Hosp_Id_r'].isin(hosp_lookup)
    sheet1.loc[mask, 'Match'] = sheet1.loc[mask, 'Account_Hosp_Id_r'].map(hosp_lookup)
    
    mask = sheet1['Match'].isna() & sheet1['Account_Mco__Id_r'].isin(mco_lookup)
    sheet1.loc[mask, 'Match'] = sheet1.loc[mask, 'Account_Mco__Id_r'].map(mco_lookup)
    
    mask = sheet1['Match'].isna() & sheet1['DomainEmail'].isin(website_lookup)
    sheet1.loc[mask, 'Match'] = sheet1.loc[mask, 'DomainEmail'].map(website_lookup)
    
    # Parallel fuzzy matching for remaining records
    remaining = sheet1[sheet1['Match'].isna()]
    if not remaining.empty:
        with ProcessPoolExecutor() as executor:
            matches = list(executor.map(fuzzy_match_wrapper, 
                                     zip(remaining['Account_Name'], 
                                         [sheet2_names]*len(remaining))))
        
        sheet1.loc[remaining.index, 'Match'] = [m[0] if m else np.nan for m in matches]
    
    return sheet1

def validate_columns(df, required_cols, sheet_name):
    """Validate required columns exist in DataFrame"""
    missing = [col for col in required_cols if col not in df.columns]
    if missing:
        raise ValueError(f"Missing columns in {sheet_name}: {', '.join(missing)}")

def main():
    # Create output directory if needed
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    try:
        # Read input files
        sheet1 = pd.read_excel(sheet1_path)
        sheet2 = pd.read_excel(sheet2_path)
        
        # Validate columns
        validate_columns(sheet1, ['Id', 'Company', 'Email', 'DomainEmail', 
                                'Account_Name', 'Account_Hosp_Id_r', 'Account_Mco__Id_r'], 'Sheet1')
        validate_columns(sheet2, ['Id', 'Name', 'Website', 'Website_2', 
                                'Account_Hosp_Id', 'Account_Mco__Id'], 'Sheet2')
        
        # Run optimized matching
        result = optimize_matching(sheet1, sheet2)
        
        # Save output
        result.to_excel(output_path, index=False)
        print(f"Success! Output saved to: {output_path}")
    
    except Exception as e:
        print(f"Error: {str(e)}")
        exit(1)

if __name__ == '__main__':
    main()
